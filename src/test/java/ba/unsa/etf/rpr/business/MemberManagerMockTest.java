package ba.unsa.etf.rpr.business;

import ba.unsa.etf.rpr.dao.DaoFactory;
import ba.unsa.etf.rpr.dao.MemberDaoSQLImpl;
import ba.unsa.etf.rpr.domain.Member;
import ba.unsa.etf.rpr.exceptions.LibraryException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

public class MemberManagerMockTest {
    private MemberManager memberManager;
    private Member member;
    private MemberDaoSQLImpl memberDaoSQL;
    private List<Member> members;

    @BeforeEach
    public void setup() {
        memberManager = Mockito.mock(MemberManager.class);
        member = new Member();
        member.setId(1);
        member.setFirstName("Test First Name");
        member.setLastName("Test Last Name");
        member.setUsername("TestUsername");
        member.setPassword("TestPassword");
        memberDaoSQL = Mockito.mock(MemberDaoSQLImpl.class);
        members = new ArrayList<>();
        members.addAll(Arrays.asList(
                new Member("First Name a", "Last Name a", "Username1", "Password1", false),
                new Member("First Name b", "Last Name b", "Username2", "Password2", false),
                new Member("First Name c", "Last Name c", "Username3", "Password3", true),
                new Member("First Name d", "Last Name d", "Username4", "Password4", true)
        ));
    }
    /*
    The test defines when the right validateMember method will be called, and tests it
    with correct parameters, and then with incorrect ones, checking whether the expected
    exception was thrown.
     */
    @Test
    public void testValidateValid() {
        try {
            Mockito.doCallRealMethod().when(memberManager).validateMember(member);
            memberManager.validateMember(member);
        } catch (LibraryException e) {
            fail();
        }
    }
    @Test
    public void testValidateInvalid() throws LibraryException {
        Mockito.doCallRealMethod().when(memberManager).validateMember(member);
        memberManager.validateMember(member);
        // This username is not in valid format and method validateMember should throw an exception
        member.setUsername("&&");
        Mockito.doCallRealMethod().when(memberManager).validateMember(member);
        LibraryException exception = assertThrows(
                LibraryException.class,
                () -> memberManager.validateMember(member),
                "Expected update to throw LibraryException, but it didn't"
        );
        assertEquals(exception.getMessage(), "Username can only contain letters, numbers, underscores, dots, and dashes.");
    }
    @Test
    public void testAdd() throws LibraryException {
        memberManager.add(member);
        assertTrue(true);
        Mockito.verify(memberManager).add(member);
    }
    @Test
    public void testAddWithId() throws LibraryException {
        Mockito.doCallRealMethod().when(memberManager).add(member);
        // member has a value set for id, which should throw an exception
        LibraryException exception = assertThrows(
                LibraryException.class,
                () -> memberManager.add(member),
                "Expected update to throw LibraryException, but it didn't"
        );
        assertEquals(exception.getMessage(), "Can't add member with ID. ID is autogenerated");
        Mockito.verify(memberManager).add(member);
    }
    @Test
    public void testMockingStaticMethods() throws LibraryException {
        MockedStatic<DaoFactory> daoFactoryMockedStatic = Mockito.mockStatic(DaoFactory.class);
        daoFactoryMockedStatic.when(DaoFactory::memberDao).thenReturn(memberDaoSQL);
        /*
        We define the behavior of the getAll method, where we also
        call the memberDao static method from the DaoFactory
         */
        when(DaoFactory.memberDao().getAll()).thenReturn(members);
        // Checking if memberDao method is really called
        daoFactoryMockedStatic.verify(DaoFactory::memberDao);
        List<Member> mockedMembers = DaoFactory.memberDao().getAll();
        // Checking if getAll returns what we defined
        assertEquals(mockedMembers, members, "The desired behavior of the getAll method was not realized!");
        daoFactoryMockedStatic.close();
    }
}
